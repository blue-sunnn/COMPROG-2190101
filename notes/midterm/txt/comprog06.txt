n = input().split()

n[0] = int(n[0], 2)
n[1] = int(n[1], 2)
ans = bin(n[0] + n[1])

print(ans[2:])

def is_prime(n) :
  # Check if n is a prime number
  if n <= 1 :
    return False
  for k in range(2, int(n ** 0.5) + 1) :
    if n % k == 0 :
      return False
  return True

def next_prime(n) :
  # Return the least prime number which is more than n
  n += 1
  while not (is_prime(n)) : n += 1
  return n

def next_twin_prime(n) :
  # Return the least twin prime number which is more than n
  # twin prime number are 2 prime numbers differed by 2
  n += 1
  while not(is_prime(n) and is_prime(n + 2)) : n += 1
  return n, n + 2

exec(input().strip())

def read_answers():
    N = int(input())
    answers = []
    for k in range(N):
        sid, ans = input().split()
        answers.append([sid, ans])
    return answers

def marking(answer, solution):
    score = 0
    for i in range(len(answer)):
        if answer[i] == solution[i]:
            score += 1
    return score

def grading(score):
    g = [[80, "A"], [70, "B"], [60, "C"], [50, "D"]]
    for a, b in g:
        if score >= a:
            return b
    return "F"

def scoring(answers, solution):
    scores = []
    for sid, ans in answers:
        score = marking(ans, solution) / len(solution) * 100
        grade = grading(score)
        scores.append([sid, score, grade])
    return scores

def report(scores):
    for sid, sc, grade in scores:
        print(sid, sc, grade)

def sort(scores):
    x = []
    for sid, score, grade in scores:
        x.append([score, sid, grade])
    x.sort()
    for i in range(len(x)):
        scores[i] = [x[i][1], x[i][0], x[i][2]]

# code
sol = input()
marked_scores = scoring(read_answers(), sol)
sort(marked_scores)
report(marked_scores[::-1])

def distance1(x1, y1, x2, y2) :
  # return the distance between points (x1, y1) and (x2, y2)
  return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5

def distance2(p1, p2) :
  # p1 = [x1, y1] and p2 = [x2, y2]
  # return the distance between p1 and p1
  x1, y1 = p1[0], p1[1]
  x2, y2 = p2[0], p2[1]
  return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5

def distance3(c1, c2) :
  # c1 = [x1, y1, r1] and c2 = [x2, y2, r2]
  # return the distance between the center of c1 and c2 and display if c1 and c2 are overlapping or not
  d = distance2(c1[:2], c2[:2])
  if d <= (c1[2] + c2[2]) : overlap = True
  else : overlap = False
  return d, overlap

def perimeter(points) :
  # points = [[x1, y1], [x2, y2], ...]
  # use those points to calculate polygon perimeter
  d = []
  for i in range(len(points) - 1) :
    d.append(distance2(points[i], points[i + 1]))
  d.append(distance2(points[len(points) - 1], points[0]))
  return sum(d)

exec(input().strip())

def make_int_list(x) :
  # x is string and convert it to int in list
  return list(map(int, x.split()))

def is_odd(e) :
  # check if e is odd or not
  return e % 2 != 0

def odd_list(alist) :
  # return list of odd numbers
  x = []
  for i in alist :
    if i % 2 != 0 : x.append(i)
  return x

def sum_square(alist) :
  # sum of square of each number in list
  x = 0
  for i in alist :
    x += i ** 2
  return x

exec(input().strip())

def read_date():
  # return a list containing day, month, year
  mname = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
  date = input().split()
  d = int(date[0])
  m = mname.index(date[1][:3]) + 1
  y = int(date[2])
  return [d, m, y]

def zodiac(d, m):
  # return the zodiac sign given day and month
  if d >= 22 and m==3 or d <=21 and m==4 : return "Aries"
  elif d >= 22 and m==4 or d <=21 and m==5 : return "Taurus"
  elif d >= 22 and m==5 or d <=21 and m==6 : return "Gemini"
  elif d >= 22 and m==6 or d <=21 and m==7 : return "Cancer"
  elif d >= 22 and m==7 or d <=21 and m==8 : return "Leo"
  elif d >= 22 and m==8 or d <=21 and m==9 : return "Virgo"
  elif d >= 22 and m==9 or d <=21 and m==10 : return "Libra"
  elif d >= 22 and m==10 or d <=21 and m==11 : return "Scorpio"
  elif d >= 22 and m==11 or d <=21 and m==12 : return "Sagittarius"
  elif d >= 22 and m==12 or d <=20 and m==1 : return "Capricorn"
  elif d >= 21 and m==1 or d <=20 and m==2 : return "Aquarius"
  elif d >= 21 and m==2 or d <=21 and m==3 : return "Pisces"

def days_in_feb(y):
  # return number of days in February of given year
  n = 28
  if y % 400 == 0 or y % 100 != 0 and y % 4 == 0 : n = 29
  return n

def days_in_month(m, y) :
  # return number of days from given month and year
  mdays = [0, 31, days_in_feb(y), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  return mdays[m]

def days_in_between(d1, m1, y1, d2, m2, y2):
  days = 0
  if m1 < 12 : days += 31
  if m1 < 11 : days += 30
  if m1 < 10 : days += 31
  if m1 < 9 : days += 30
  if m1 < 8 : days += 31
  if m1 < 7 : days += 31
  if m1 < 6 : days += 30
  if m1 < 5 : days += 31
  if m1 < 4 : days += 30
  if m1 < 3 : days += 31
  if m1 < 2 : days += days_in_feb(y1)
  if m2 > 1 : days += 31
  if m2 > 2 : days += days_in_feb(y2)
  if m2 > 3 : days += 31
  if m2 > 4 : days += 30
  if m2 > 5 : days += 31
  if m2 > 6 : days += 30
  if m2 > 7 : days += 31
  if m2 > 8 : days += 31
  if m2 > 9 : days += 30
  if m2 > 10 : days += 31
  if m2 > 11 : days += 30
  return days + (days_in_month(m1,y1) - d1 + 1) + int((y2 - y1 - 1)*365.25) + (d2 - 1)

def main() :
    d1, m1, y1 = read_date()
    d2, m2, y2 = read_date()
    print(zodiac(d1, m1), zodiac(d2, m2))
    print(days_in_between(d1, m1, y1, d2, m2, y2))

exec(input().strip())